# -*- coding: utf-8 -*-
"""CapstoneSetup.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eNOKApiRGq6uJPzJPLm_vL-k94E6f2xo
"""

!pip install roboflow

from roboflow import Roboflow
rf = Roboflow(api_key="11111111111")#your telegram API key
project = rf.workspace("song-guo-chang").project("dog-and-cat-eu2ol-gnx6j")
version = project.version(2)
dataset = version.download("yolov11")

# prompt: import ultralytics and yolov11, and train it

!pip install ultralytics

from ultralytics import YOLO

# Load a model
model = YOLO('yolo11s.pt')  # load a pretrained model (recommended for training)

# Train the model
results = model.train(data=f'/content/dog-and-cat-2/data.yaml', epochs=10) #replace with the number of epochs you want

!pip install pyngrok flask

!ngrok config add-authtoken 2ys3CASFwOlgragk5d9MHcj0aOr_63mR8GufA7Hgwy63gA4b4

from flask import Flask, request, jsonify
from pyngrok import ngrok
from ultralytics import YOLO

# Load your trained model
model = YOLO('/content/runs/detect/train2/weights/best.pt')

# Start Flask app
app = Flask(__name__)

@app.route("/predict", methods=["POST"])
def predict():
    image = request.files['image']
    image_path = "/content/temp.jpg"
    image.save(image_path)

    results = model(image_path)
    boxes = results[0].boxes

    if boxes is not None and len(boxes.cls) > 0:
        class_id = int(boxes.cls[0].item())
        class_name = model.names[class_id]
        return jsonify({"product": class_name})
    else:
        return jsonify({"product": "No product detected"})

# Start ngrok tunnel
public_url = ngrok.connect(5000)
print(f"ðŸ”— Public URL: {public_url}")

# Run the Flask app
app.run(port=5000)
'''
from google.colab import drive
import os
drive.mount('/content/drive')

input_folder = "/content/drive/MyDrive/intellikiosk/input"
output_folder = "/content/drive/MyDrive/intellikiosk/output"
os.makedirs(input_folder, exist_ok=True)
os.makedirs(output_folder, exist_ok=True)

import time
from pathlib import Path

print("Watching for new images...")

while True:
    image_files = list(Path(input_folder).glob("*.jpg"))
    for img_path in image_files:
        print(f"Processing {img_path.name}")
        result = model.predict(str(img_path), save=True, save_txt=True, conf=0.25)

        # Save results (e.g., detected class names)
        labels = result[0].names
        classes = result[0].boxes.cls.cpu().numpy().astype(int)
        detections = [labels[c] for c in classes]
        result_path = Path(output_folder) / (img_path.stem + ".txt")
        with open(result_path, "w") as f:
            f.write(", ".join(set(detections)) or "No objects detected")

        os.remove(img_path)  # cleanup processed image

    time.sleep(5)
    '''
